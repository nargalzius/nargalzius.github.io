version = '1.0'
path = 'flash/joystick/as3/studio/v2/expanding'
file = 'sample.zip'
title = 'Joystick Studio v2 Expandable'

!!!5
html
	head
		meta(http-equiv="Content-Type", content="text/html; charset=utf-8")
		title #{title} 
		link(rel="stylesheet", type="text/css", href="../../../../../../f/c/readme.css")

		script(src="http://cdnjs.cloudflare.com/ajax/libs/jquery/1.7.2/jquery.min.js")
		script(src="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/7.3/highlight.min.js")

	body
		
		header#info

			img#logo(src="../../../../../../img/joystick/logo.png", alt="Joystick Interactive")

			h1 #{title}

			:markdown

				The purpose of this set of AS3 Class files is to standardize the implementation of core functionality of Studio expandables used by the organization and accomodate typical behavior required for most implementations.

				As an example, take a look at the various implementations of ads in [this [test] demo campaign](http://www.google.com/doubleclick/studio/ua/externalpreview#gr8bWOl_S3KVZB9PcCSb7w). All the files have the same document classes under the hood, and have minimal code and elements to accomplish the animations, maskings, borders, etc.

				Another goal of such an approach is that since majority the core expandable functionality has been abstracted outside of the Flash files, it is possible to create [similar document classes for non-Studio expandables](http://nargalzius.github.io/flash/joystick/as3/expanding) in such a way that porting regular demos to Studio implementations can be achieved mostly by just switching the document classes. 

				This unfortuantely doesn't cover the video components - so you'll still have to convert those manually. But who knows...

			h3 Resources

			ul
				li
					a(href="#usage") Getting Started
				li
					a(href="#api") Full Documentation  
				li
					a(target="_blank", href="https://github.com/nargalzius/joystick_flash/tree/master/as3") ActionScript Classes 
					| (AS3)
				li
					a(target="_blank", href="https://github.com/nargalzius/joystick_flash/tree/master/fla/as3_studio_expanding") Sample Implementation 
					| (.fla)
				li
					a(href="#changelog") Changelog

			:markdown

				### Requirements/Dependencies

				- Flash Player 9 or higher
				- ActionScript 3
				- [DoubleClick Studio Component v2](https://support.google.com/richmedia/answer/2389098?hl=en) (AS3)
				- [GreenSock Animation Platform](http://www.greensock.com)

		section#usage

			h1 Quick Start

			:markdown

				So let's say we want to make a `300x250` unit that expands to `500x250` to the _left._ We'll use the [typical] 3-file approach: One file as `parent.swf` with a canvas size of 500x250, the other as `collapsed.swf` with a canvas size of 300x250, and lastly, one called `expanded.swf` with 500x250 as its canvas size.

				### Parent SWF

				For `parent.swf`, we only need to have **two** components on the stage; the `Studio enabler`, and the `expanding component` - both of which are included in the DoubleClick Studio Extension set. That's it, nothing more - the rest we'll do programatically ;)

				Set the `expanding component` to the size of your collapsed state (300x250) and position it where you wish it to be placed relative to its expanded state. Do not set anything on the component via the inspector. Merely resize it and position it.

				Now set `parent.swf's` **document class** to `com.joystick.studio.v2.Expand`. What you just did was include a base class that automatically calculates and generates the masks, movieclips, animations, event handlers, etc. that for core expanding functionality. 

				Only thing left to do is initialize it manually _after_ we set some parameters via ActionScript. Put this AS3 code in the first frame of your actions layer.

			.fullCode
				pre.syntax.html.
					/* SET PARAMETERS */
					_COLLAPSED = "FILENAME.swf";
					_EXPANDED = "FILENAME.swf";
					//_DURATION = 1;
					//_AUTOEXPAND = true;
					//_AUTOCOLLAPSE = 8;
					//_ACCOI = false;
					//_MOUSECOLLAPSE = true;
					//_PUSHDOWN = true;
					//_DIRECTION = "L";
					//_BORDER = NaN;
					//debug = true;

					/* INITIALIZE STUDIO */
					init();

			:markdown

				The full details on the variables listed above are discussed in the [API section](#api). But for our purposes, All you need to uncomment is the `_DIRECTION` variable - which is conveniently set to `L`. 

				You can see that at the end of it all, the initialization call `init()` is made. Your `parent.swf` is now ready. Let's move on and setup the children.

				### Collapsed SWF

				For the `collapsed.swf` we need two `displayObject`s on the stage: one for your **background exit** button, and another for your **expand** trigger. Give them both instance names.

				Set the document class of your collapsed swf to `com.joystick.studio.v2.CollapsedChild`

				The only thing to remember is that you must use a `MovieClip` for your **exit** button - as for some reason, the document class it fails to assign the trigger if it's a button. Shouldn't be an issue though.

				Now paste this code on the actions layer

			.fullCode
				pre.syntax.actionscript.
					function metaHandler(e:Event):void
					{
						switch(e.type)
						{
							case "META_TRIGGERED": 
								/* USER ACTIONS WHEN EXPAND/COLLAPSE IS TRIGGERED */
							break;
							case "META_EXPANDING": 
								/* USER ACTIONS WHEN EXPAND ANIMATION STARTS */
							break;
							case "META_EXPANDED": 
								/* USER ACTIONS WHEN EXPAND ANIMATION FINSIHES */
							break;
							case "META_COLLAPSING": 
								/* USER ACTIONS WHEN COLLAPSE ANIMATION STARTS */
							break;
							case "META_COLLAPSED": 
								/* USER ACTIONS WHEN COLLAPSE ANIMATION FINISHES */
							break;
						}
					}

					_EXIT = INSTANCE;
					_TRIGGER = INSTANCE;
					//_DELAY = 0;
					//_ROLLOVER = true;
					//debug = true;

					init();

			:markdown

				I'll discuss the metaHandler later, but for now, focus on the four variables above the `init()` call. You basically assign the two displayObjects accordingly - then the document class will automatically generate the appropriate listeners and calls for expand and exit, make the exit button transparent and resize it to fill the entire stage.

				### Expanded SWF

				For the expanded file, simply duplicate the collapsed file and resize the stage to the expanded dimensions (500x250). Also, change its document class to `com.joystick.studio.v2.ExpandedChild`. 

				What you just did was _automatically_ switch the behavior of the [expand] trigger to **collapse** the ad, and the exit button to report a background exit from the expanded state. All you really need to do at this point is simply change the text on your "trigger button" (which I imagene would be something like "click to expand") to better represent a **close/collapse** action.

				Congratulations. You now have a basic working expanding ad. Of course I need not remind you that Studio-related events will not fire unless you're running everything from the main parent (with the main Enabler).


				### Anatomy of the Expanding Class(es)
				
				The template does so much more behind the scenes - hopefully the API would help in explaning it better. But for those who are curious as to what "process" this system follows for buildilng core functionality, here's a how a typical implementation of the ad would work.

				#### On initial load.

				1. Parent swf is loaded (let's call it `Parent`), 
				2. Container movieclips are created (to be populated by StudioLoader)
				3. Masks, and transition animations are determined and set depending on the user-settings.
				4. Collapsed swf is loaded (let's call it `Collapsed`) via Polite Load (done programatically, so the PoliteLoad component icon will not appear in Studio webpage's "component" tab)

				#### On user expand

				1. `Collapsed` notifies `Parent` to load expanded swf (let's call it `Expanded`).
				2. `Parent` starts loading `Expanded` but **does not** expand yet. This is to ensure that the expansion animation is only started when `Expanded` is fully ready to be displayed.
				3. When `Expanded` is fully ready, `Parent` requests for confirmation from `Collapsed` to proceed expanding... The reason it doesn't do it automatically is to accomodate `Collapsed`'s `_DELAY` variable (read the API for more).  
					`META_TRIGGERED` is also fired on `Collapsed` at this point.
				4. `Child` receives `Parent`'s request, and starts a timer to make the final expand call (i.e. an "all green" signal) based on its `_DELAY` variable.  
					By default, `_DELAY` is set to zero - so that means as soon as `Expanded` is ready, `Collapsed` will instantaneously give `Parent` the "all-green" to perform the expand transition.
				5. `Parent` receives final expand call from `Collapsed` and performs expansion animation based on `Parent`'s `_DURATION` variable. Both `Collapsed` and `Collapsed` are "disabled" to prevent extraneous input that can mess with the wole procedure.  
					`META_EXPANDING` is also fired to _both_ `Collapsed` _and_ `Expanded` at this point. 
				6. When expansion animation is done, `META_EXPANDED` is fired to _both_ `Collapsed` and `Expanded`

				#### On user close, exit event, or mousecollapse (if applicable)

				1. Like with `Collapsed`'s expansion delay, `Expanded` starts a timer to make the final collapse call based on its `_DELAY` variable.  
					`META_TRIGGERED` is fired at this point.
				2. When the timer is done, (immediately by default), it tells `Parent` to start collapse animation.
				3. `Parent` receives instruction and starts collapse animation.  Both `Collapsed` and `Collapsed` are "disabled".  
					`META_COLLAPSING` is fired on both.
				4. When collapse animation is done, `Expanded` is unloaded, and `META_COLLAPSED` if fired on `Collapsed`

		section#api
			h1 API

			h2 Parent SWF

			:markdown
				Document class file:  
				`com.joystick.studio.v2.Expand` (extends Enabler)

			ul
				li
					strong
						code.property debug  
					code.property : Boolean = 
					em 
						code.property false

					:markdown
						Toggle trace of various actions for debugging

						Also, if you want to disable the "clutter" that the [Studio Logger](http://www.google.com/doubleclick/studio/docs/sdk/flash/as3/en/com_google_ads_studio_utils_Logger.html) generates, you can use this:

					.quickCode
						pre.syntax.actionscript.
							import com.google.ads.studio.utils.Logger;
							Logger.setLogLevel(Logger.NONE);

				li
					strong
						code.property _COLLAPSED 
					code.property : String

					:markdown

						Filname of collapsed file.

						The parent swf automatically generates a container, which the collapsed file is loaded into. Furthermore, it creates a mask (for the sake of neatness) for the child based on the dimensions of the `expanding` component (which you manually set) - it then positions the child (and it's mask) on the same location of the expanding component.

						This is the reason why it's not necessary to "set" the expanding component to load any file via its component inspector.

				li
					strong
						code.property _EXPANDED 
					code.property : String

					:markdown

						Filname of expanded file.

						Like with the collapsed swf, the parent generates the appropriate container in which to load the file onto. It also generates the appropriate mask.

						When an expand is triggered, the expand animation only starts when the expanded has been fully loaded. Likewise, it is fully unloaded when a collapse completes.

				li
					strong
						code.property _DURATION 
					code.property : Number = 
					em
						code.property 1

					:markdown

						The default expansion animation time. You may set it faster for normal expands, but it's advisable to keep it at `1` second or longer for _PUSHDOWNs.

						set it to `0` if you want an immediate expand (popup). [Example](http://www.google.com/doubleclick/studio/ua/externalpreview#gr8bWOl_S3KVZB9PcCSb7w/creativeId=24665846)
				li
					strong
						code.property _AUTOEXPAND 
					code.property : Boolean = 
					em
						code.property false

					:markdown
						Self-explanatory. When enabled, the collapsed state will be invisible on initial load. This is to make sure that the first thing the user sees is the expanded animation/state. [Example](http://www.google.com/doubleclick/studio/ua/externalpreview#gr8bWOl_S3KVZB9PcCSb7w/creativeId=24666758)
				li
					strong
						code.property _AUTOCOLLAPSE 
					code.property : Number = 
					em
						code.property 0

					:markdown
						The number of seconds before an auto-collapse is executed. When set to 0, it's disabled. [Example](http://www.google.com/doubleclick/studio/ua/externalpreview#gr8bWOl_S3KVZB9PcCSb7w/creativeId=24666758)
				li
					strong
						code.property _ACCOI 
					code.property : Boolean = 
					em
						code.property true

					:markdown
						Short for **A**uto **C**ollapse **C**ancel **O**n **I**nteraction. This listens for the `StudioEvent.INTERACTION` event, which is Studio's own way of telling if a user has interacted with a unit. [Example](http://www.google.com/doubleclick/studio/ua/externalpreview#gr8bWOl_S3KVZB9PcCSb7w/creativeId=24666763)

						Because it's not really clear how Studio "determines" what constitutes an "interaction", you may opt to bypass it entirely (i.e. if you want it cancelled by different rules) by setting it to `false`

						The cancellation can be manually called through the following event: 

					.quickCode
						pre.syntax.actionscript.
							parent.dispatchEvent(new Event("KILL_AUTOCOLLAPSE"));
				li
					strong
						code.property _MOUSECOLLAPSE 
					code.property : Boolean = 
					em
						code.property false

					:markdown
						Collapse on mouseout. If the user navigates away from the unit, it will collapse. [Example](http://www.google.com/doubleclick/studio/ua/externalpreview#gr8bWOl_S3KVZB9PcCSb7w/creativeId=24666755)
				li
					strong
						code.property _PUSHDOWN 
					code.property : Boolean = 
					em
						code.property false

					:markdown
						Set triggers for Pushdown functionality. Both regular expandables and pushdowns call `expanding.expand()` at the same time. But they call `expanding.collapse()` at different times.

						Regular animated expands have to make the call when the collapse animation is done, whereas the _PUSHDOWNs call it at the same time the collapse animation starts.

						Pushdowns also have no easing in their expansion animations - to match the lack of easing on the HTML animations. [Example](http://www.google.com/doubleclick/studio/ua/externalpreview#gr8bWOl_S3KVZB9PcCSb7w/creativeId=24666758)
				li
					strong
						code.property _DIRECTION  
					code.property : string = 
					em 
						code.property 'D'

					:markdown
						Direction of the expand. Mask transitions/animations are done automatically. Accepts the following values (case sensitive):

					ul
						li 
							code.property D 
							| (Down, default) expands downward from top

						
						li 
							code.property U 
							| (Up) expands upward from bottom
						
						li 
							code.property L 
							| (Left) expands left from right
						
						li 
							code.property R 
							| (Right) expands right from left
						
						li 
							code.property LU 
							| (Left/Up) expands diagonally to top-left from bottom-right 
							a(href="http://www.google.com/doubleclick/studio/ua/externalpreview#gr8bWOl_S3KVZB9PcCSb7w/creativeId=24665841") Example

						li 
							code.property LD 
							| (Left/Down) expands diagonally to bottom-left from top-right

						
						li 
							code.property RU 
							| (Right/Up) expands diagonally to top-right from bottom-left

						
						li 
							code.property RD 
							| (Right/Down) expands diagonally to bottom-right from top-left
						
						li 
							code.property O 
							| (Omni) expands outward to all directions from center of collapsed child 

							a(href="http://www.google.com/doubleclick/studio/ua/externalpreview#gr8bWOl_S3KVZB9PcCSb7w/creativeId=24666763") Example
				li
					strong
						code.property _BORDER 
					code.property : Number = 
					em
						code.property 0x000000

					:markdown
						Automatically generates a stroke/border around the expanded/collapsed MCs as they are loaded to the stage.

						Accepts numbers in "hex color value format" that Flash understands natively (i.e. pre-pended by `0x`). It defaults to black (`0x000000`).

						Most of the time, borders are required, so I thought it would be good to just include this as default behavior. If you wish to disable the borders for some cases, you can set `_BORDER` to a non-finite number such as `-1` or `NaN`.

			h2 Children SWFs

			:markdown

				Document class file(s):  
				`com.joystick.studio.v2.CollapsedChild` (extends ExpandProxy)  
				`com.joystick.studio.v2.ExpandedChild` (extends ExpandProxy)

			ul
				li
					strong
						code.property debug  
					code.property : Boolean = 
					em 
						code.property false

					:markdown
						Toggle trace of various actions for debugging
				li
					strong
						code.property _TRIGGER 
					code.property : Button / MovieClip

					:markdown
						Trigger button. Whether it triggers an expand or collapse depends on what document class your file is using.
				li
					strong
						code.property _EXIT 
					code.property : MovieClip

					:markdown
						Studio fails to register the exit event if this is set to a button. But it's basically your background exit button.
				li
					strong
						code.property _DELAY 
					code.property : Boolean = 
					em
						code.property false

					:markdown
						A delay before the expand or collapse is called. Useful to for having pre-expand/collapse animations. [Example](http://www.google.com/doubleclick/studio/ua/externalpreview#gr8bWOl_S3KVZB9PcCSb7w/creativeId=24677336)
				li
					strong
						code.property _ROLLOVER 
					code.property : Boolean = 
					em
						code.property false

					:markdown
						Assigns your trigger to be fired on rollover. [Example](http://www.google.com/doubleclick/studio/ua/externalpreview#gr8bWOl_S3KVZB9PcCSb7w/creativeId=24666755)

						If you feel that you want to override (or augment) the functionality of the unit, you can always manually trigger expands/collapses in the timeline by using `expand()` or `collapse()`.

			:markdown
				### The `metaHandler()` function

				From the code snippet above, these are the events that the metaHandler intercepts.

			ul
				li
					strong
						code.property META_TRIGGERED 
					code.property : Event

					:markdown
						Fired when a collapse/expand is triggered.

						It's worth remembering that this isn't necessarily an "immediate trigger" - triggers from either state (collapsed/expanded) will both respect whatever `_DELAY` setting you have.

						However, in the case of the collapsed state trying to expand, it will only "trigger" once it has confirmed with the parent that the expanded swf is ready to be displayed.

				li
					strong
						code.property META_EXPANDING 
					code.property : Event

					:markdown
						Fired when the expanding animation starts.


				li
					strong
						code.property META_EXPANDED
					code.property : Event

					:markdown
						Triggered when expand has completed.

				li
					strong
						code.property META_COLLAPSING
					code.property : Event

					:markdown
						Triggered when collapse starts.

				li
					strong
						code.property META_COLLAPSED
					code.property : Event

					:markdown
						Triggered when collapse has completed.

			:markdown

				#### Practical Example of metaHandler event use

				Take a look at [this example unit.](http://www.google.com/doubleclick/studio/ua/externalpreview#gr8bWOl_S3KVZB9PcCSb7w/creativeId=24677336) It may look very simple, but it's more complex than it seems.

				1. The collapsed animation should fade to black **before** the expand starts. (`META_TRIGGERED` in conjunction with `_DELAY`)
				2. The expanded swf starts from black and fades into view only **after** the expand animation's done.  
					Furthermore, the YouTube player component initialization is likewise done after expansion to avoid freezing/jerking while expanding. (`META_EXPANDED`)
				4. Expanded animation fades to black **before*** collapsing (same approach as #1)
				5. YouTube player instance is destroyed (`instance.destroy()`) as part of garbage collection when collapse animation starts. (`META_COLLAPSING`)
				6. Like with #2, the collapse SWF now starts from black and fades into view **after** the collapse is done - but with `META_COLLAPSED` this time.
				7. You may or may not have noticed it, but the collapsed frame alternates between frame 1 and 2 on every collapse - this is triggered during `META_EXPANDED`

				As you can see, only `META_EXPANDING` seems to be useless (but it's included just in case one may find a use for it). The rest have real practical value depending on what type of implementation you intend to do.

				If you also would notice, if you have the `_DELAY` set and code "collapse animations" accordingly, the collapse will always do it _regardless_ of what triggered it.

				So leaving the unit while having `_MOUSECOLLAPSE`, or pressing the close button, or doing an exit event will always run through the animation sequence for a more graceful collapse.

				## Bullet-proofing

				I've also tried protecting the unit from unexpected calls as far as the core functionality (expand/collapse) goes.

				For example, an expand/collapse is fired only once (for every transition) even if you click rapidly. In the recent sample unit, because of the 1-second `_DELAY`, you can actually click on the exit, close button, and move out the unit (though `_MOUSECOLLAPSE` isn't enabled.) before the collapse starts - imagine what mayhem this could cause to your actions in the `META` handler (as they'd probably be called multiple times) - as well as the messy reporting to the Studio console.

				Likewise, expand/collapse calls cannot be done **during** a [expand/collapse] transition. So if you click on the background exit, or mouseout (assuming you have `_MOUSECOLLAPSE` enabled) **while** the unit is expanding/collapsing, it will proceed with what it's doing. It essentially "disables" the unit during the transitions, to avoid buggy behavior.

		section#changelog

			:markdown
				Changelog
				=========

				## 1.0

					- Initial release

		script.
			$(document).ready(function() {
				$('pre.syntax').each(function(i, e) {hljs.highlightBlock(e)});
			});